<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.9.23">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Kara C. Hoover">

<title>Few-Shot Prompt Engineering Achieves Production-Grade Biometric Security Auditing Without Fine-Tuning</title>
<style>
/* Default styles provided by pandoc.
** See https://pandoc.org/MANUAL.html#variables-for-html for config info.
*/
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="xai-prompt-engineering-bedrock_files/libs/clipboard/clipboard.min.js"></script>
<script src="xai-prompt-engineering-bedrock_files/libs/quarto-html/quarto.js" type="module"></script>
<script src="xai-prompt-engineering-bedrock_files/libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="xai-prompt-engineering-bedrock_files/libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="xai-prompt-engineering-bedrock_files/libs/quarto-html/popper.min.js"></script>
<script src="xai-prompt-engineering-bedrock_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="xai-prompt-engineering-bedrock_files/libs/quarto-html/anchor.min.js"></script>
<link href="xai-prompt-engineering-bedrock_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="xai-prompt-engineering-bedrock_files/libs/quarto-html/quarto-syntax-highlighting-076ecbd647e1f0418c5051713cd9b730.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="xai-prompt-engineering-bedrock_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="xai-prompt-engineering-bedrock_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="xai-prompt-engineering-bedrock_files/libs/bootstrap/bootstrap-fdc35ccebf6ef883c9ad23e25989f106.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">


</head>

<body class="blues quarto-light">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
  <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#executive-summary" id="toc-executive-summary" class="nav-link active" data-scroll-target="#executive-summary">Executive Summary</a></li>
  <li><a href="#research-question" id="toc-research-question" class="nav-link" data-scroll-target="#research-question">Research Question</a></li>
  <li><a href="#research-answers" id="toc-research-answers" class="nav-link" data-scroll-target="#research-answers">Research Answers</a>
  <ul class="collapse">
  <li><a href="#few-shot-design-determines-classification-reliability" id="toc-few-shot-design-determines-classification-reliability" class="nav-link" data-scroll-target="#few-shot-design-determines-classification-reliability">Few-Shot Design Determines Classification Reliability</a></li>
  <li><a href="#test-cases-all-three-scenarios-resolved-correctly" id="toc-test-cases-all-three-scenarios-resolved-correctly" class="nav-link" data-scroll-target="#test-cases-all-three-scenarios-resolved-correctly">Test Cases: All Three Scenarios Resolved Correctly</a></li>
  <li><a href="#parameter-optimization-temperature-and-top-k" id="toc-parameter-optimization-temperature-and-top-k" class="nav-link" data-scroll-target="#parameter-optimization-temperature-and-top-k">Parameter Optimization: Temperature and Top-K</a></li>
  <li><a href="#model-comparison-production-vs.-research" id="toc-model-comparison-production-vs.-research" class="nav-link" data-scroll-target="#model-comparison-production-vs.-research">Model Comparison: Production vs.&nbsp;Research</a></li>
  </ul></li>
  <li><a href="#study-design" id="toc-study-design" class="nav-link" data-scroll-target="#study-design">Study Design</a></li>
  <li><a href="#project-resources" id="toc-project-resources" class="nav-link" data-scroll-target="#project-resources">Project Resources</a></li>
  <li><a href="#tools-technologies" id="toc-tools-technologies" class="nav-link" data-scroll-target="#tools-technologies">Tools &amp; Technologies</a></li>
  <li><a href="#expertise" id="toc-expertise" class="nav-link" data-scroll-target="#expertise">Expertise</a></li>
  </ul>
</nav>
</div>
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Few-Shot Prompt Engineering Achieves Production-Grade Biometric Security Auditing Without Fine-Tuning</h1>
  <div class="quarto-categories">
    <div class="quarto-category">prompt engineering</div>
    <div class="quarto-category">few-shot learning</div>
    <div class="quarto-category">LLM</div>
    <div class="quarto-category">AWS Bedrock</div>
    <div class="quarto-category">biometrics</div>
    <div class="quarto-category">parameter optimization</div>
  </div>
  </div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Kara C. Hoover </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">February 2026</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<section id="executive-summary" class="level2">
<h2 class="anchored" data-anchor-id="executive-summary">Executive Summary</h2>
<p><strong>Problem:</strong> Biometric systems must make real-time pass/fail/retry decisions about sensor data quality, but traditional rule-based approaches require explicit thresholds for every sensor combination, struggle with environmental edge cases, and cannot provide natural language remediation guidance.</p>
<p><strong>Approach:</strong> Developed a prompt engineering framework using AWS Bedrock to evaluate whether LLMs can classify biometric sensor telemetry and generate structured remediation logic without custom fine-tuning. Tested Amazon Nova Lite and Claude 4.5 Opus across three edge case scenarios (low light, 2D spoof, ambiguous glare) using few-shot prompting and systematic parameter sweeps across Temperature, Top-K, and Top-P.</p>
<p><strong>Insights:</strong> Few-shot prompting with three carefully designed examples was sufficient to teach both models sensor modality prioritization, presentation attack detection, and remediation strategy generation. Parameter configuration – not model selection – is the critical variable: Temperature 0 with low Top-K (10–20) produces deterministic, comprehensive audit logs; Temperature 1 with the same Top-K constraint produces nuanced, prioritized user-facing instructions. Both models achieved 100% JSON schema compliance across all test cases.</p>
<p><strong>Significance:</strong> This project demonstrates that production-grade security auditing is achievable through prompt engineering alone, without the time and data costs of fine-tuning. The tiered parameter strategy – one prompt template, multiple configurations for different audiences – is a generalizable pattern applicable to any domain requiring structured LLM outputs with varying levels of determinism.</p>
<p><strong>Key Findings</strong></p>
<ul>
<li>100% JSON schema compliance across both models and all test cases</li>
<li>Three few-shot examples were sufficient for reliable sensor modality prioritization and spoof detection</li>
<li>Temperature 0 is optimal for audit logs; Temperature 1 with low Top-K (10–20) is optimal for user-facing instructions</li>
<li>Low Top-K (10–20) acts as a safety rail against hallucination regardless of Temperature setting</li>
<li>Nova Lite and Claude 4.5 Opus reached identical decisions on all test cases; they differ in reasoning depth and cost, not accuracy</li>
</ul>
<div class="callout callout-style-simple callout-note no-icon">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-body-container">
<p><strong>Applied Findings</strong></p>
<ul>
<li>Few-shot prompting with role assignment, negative output constraints, and three edge-case examples achieves production-grade structured output reliability – fine-tuning is not required for this class of problem.</li>
<li>Temperature and Top-K must be configured for the end recipient: deterministic settings for compliance audit logs, higher Temperature with constrained Top-K for user-facing remediation instructions.</li>
<li>Nova Lite is the production choice for cost and consistency; Claude 4.5 Opus is the research choice for reasoning depth on novel edge cases.</li>
</ul>
</div>
</div>
</div>
<hr>
</section>
<section id="research-question" class="level2">
<h2 class="anchored" data-anchor-id="research-question">Research Question</h2>
<p>Can few-shot prompt engineering – without fine-tuning – achieve reliable structured output and accurate anomaly classification for biometric sensor validation, and how should Temperature and Top-K parameters be configured for different operational audiences?</p>
<hr>
</section>
<section id="research-answers" class="level2">
<h2 class="anchored" data-anchor-id="research-answers">Research Answers</h2>
<section id="few-shot-design-determines-classification-reliability" class="level3">
<h3 class="anchored" data-anchor-id="few-shot-design-determines-classification-reliability">Few-Shot Design Determines Classification Reliability</h3>
<p>The prompt structure combined four elements: role assignment (“Senior Biometric Security Auditor”), task specification (analyze for presentation attacks or environmental interference), a negative output constraint (“Return ONLY a JSON object”), and three few-shot examples covering distinct edge cases – specular glare on eyewear, lower face occlusion, and low ambient light. Both models returned 100% JSON-compliant responses across all test cases.</p>
<p>The negative constraint (“Return ONLY”) proved as important as the examples themselves. Without explicit instruction about what not to include, LLMs default to conversational framing that breaks downstream JSON parsing. The few-shot examples established sensor modality logic – when to trust IR over RGB, what flat depth profiles indicate – that generalized correctly to the test scenarios.</p>
</section>
<section id="test-cases-all-three-scenarios-resolved-correctly" class="level3">
<h3 class="anchored" data-anchor-id="test-cases-all-three-scenarios-resolved-correctly">Test Cases: All Three Scenarios Resolved Correctly</h3>
<p><strong>Test Case 1 – Low Light (IR-Heuristic):</strong> RGB confidence 0.21, IR confidence 0.96 in a 2-lux environment. Expected: PASS, trusting IR over RGB. Both models returned PASS, correctly prioritizing IR liveness signal over failed RGB in low ambient light.</p>
<p><strong>Test Case 2 – 2D Spoof (Security Check):</strong> RGB confidence 0.98, IR confidence 0.15 with a flat surface depth profile. Expected: FAIL, flagging 2D presentation attack. Both models returned FAIL. The high RGB score – which a threshold rule might pass – did not mislead either model; the low IR reading was correctly interpreted as a liveness failure.</p>
<p><strong>Test Case 3 – Ambiguous Glare (Remediation Check):</strong> RGB confidence 0.55, IR confidence 0.60 with transition lens glare from overhead LED. Expected: RETRY with specific remediation. Both models returned RETRY with actionable guidance. Nova Lite suggested repositioning and removing non-prescription eyewear; Claude 4.5 Opus identified photochromic lens darkening as the primary cause and provided positioning-specific guidance.</p>
</section>
<section id="parameter-optimization-temperature-and-top-k" class="level3">
<h3 class="anchored" data-anchor-id="parameter-optimization-temperature-and-top-k">Parameter Optimization: Temperature and Top-K</h3>
<p>Temperature controls output style more than output accuracy in this setting. Temperature 0 produces comprehensive, deterministic responses – all possible causes listed, all possible remediations included, phrasing identical across repeated runs. This is the correct configuration for forensic audit logs and compliance documentation. Temperature 1 produces prioritized, targeted responses – the most likely cause identified first, more sophisticated phrasing – appropriate for real-time user-facing instructions.</p>
<p>Top-K functions as a vocabulary constraint that operates independently of Temperature. At the default Top-K of 50, high Temperature settings introduce creative drift – the model can hallucinate non-existent sensor issues by sampling from a wide token distribution. Constraining Top-K to 10–20 limits the model to the most probable next tokens at each step, preserving linguistic variety within safe bounds. The counterintuitive finding: Temperature 1 with Top-K 10 is more stable than moderate Temperature with default Top-K, because constrained vocabulary prevents the model from hedging with generic responses while still allowing nuanced phrasing.</p>
<p>Top-P at 0.8 provides a secondary anchor when responses trend verbose under high Temperature. In practice, Top-K does most of the constraint work for this use case.</p>
</section>
<section id="model-comparison-production-vs.-research" class="level3">
<h3 class="anchored" data-anchor-id="model-comparison-production-vs.-research">Model Comparison: Production vs.&nbsp;Research</h3>
<table class="caption-top table">
<thead>
<tr class="header">
<th></th>
<th>Nova Lite</th>
<th>Claude 4.5 Opus</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>JSON Compliance</strong></td>
<td>100%</td>
<td>100%</td>
</tr>
<tr class="even">
<td><strong>Decision Accuracy</strong></td>
<td>100%</td>
<td>100%</td>
</tr>
<tr class="odd">
<td><strong>Reasoning Style</strong></td>
<td>Concise</td>
<td>Verbose</td>
</tr>
<tr class="even">
<td><strong>Cost per Decision</strong></td>
<td>~$0.0001</td>
<td>~$0.001</td>
</tr>
<tr class="odd">
<td><strong>Best Use</strong></td>
<td>Production, high-volume</td>
<td>Research, novel edge cases</td>
</tr>
</tbody>
</table>
<p>Both models reached identical decisions on all test cases. The 10x cost difference is not a quality difference – it is a reasoning depth difference. Nova Lite is the production choice where consistency and throughput matter. Claude 4.5 Opus is the research choice for developing new edge case examples and auditing novel sensor configurations where detailed reasoning traces have diagnostic value.</p>
<hr>
</section>
</section>
<section id="study-design" class="level2">
<h2 class="anchored" data-anchor-id="study-design">Study Design</h2>
<p><strong>Data Source:</strong> Manually constructed test cases with synthetic sensor confidence values. No real biometric data or images were used. The LLM operates on structured JSON metadata (RGB confidence score, IR confidence score, and a contextual note field), not raw sensor images.</p>
<p><strong>Data Handling:</strong> Three edge case scenarios were hand-crafted to represent distinct failure modes: environmental interference (low light), presentation attack (2D spoof), and ambiguous sensor conflict (glare with transition lenses). Each was tested against both models under varying parameter configurations.</p>
<p><strong>Analytical Approach:</strong></p>
<ol type="1">
<li>Designed system prompt with role assignment, task specification, negative output constraint, and three few-shot examples (glare, mask, low light)</li>
<li>Constructed three test cases with known expected outputs (PASS, FAIL, RETRY)</li>
<li>Ran each test case through Amazon Nova Lite and Claude 4.5 Opus via AWS Bedrock</li>
<li>Evaluated outputs against expected decisions and JSON schema compliance</li>
<li>Conducted parameter sweep: Temperature (0, 0.5, 1.0) x Top-K (1, 10–20, 50) x Top-P (0.8, 1.0)</li>
<li>Ran stochastic consistency test – same input 3x per Temperature setting – to measure output stability</li>
<li>Compared model outputs on reasoning depth, phrasing sophistication, and cost per decision</li>
</ol>
<hr>
</section>
<section id="project-resources" class="level2">
<h2 class="anchored" data-anchor-id="project-resources">Project Resources</h2>
<p><strong>Repository:</strong> <a href="https://github.com/kchoover14/xai-prompt-engineering-bedrock">github.com/kchoover14/xai-prompt-engineering-bedrock</a></p>
<p><strong>Data:</strong> Synthetic sensor confidence values constructed for this proof-of-concept. No external data source. No real biometric data used.</p>
<p><strong>Code:</strong> No analysis script. Prompts were submitted directly to AWS Bedrock via the console and API. Prompt templates are documented in the Research Answers section above.</p>
<p><strong>Project Artifacts:</strong></p>
<ul>
<li>No figures (results presented as tables and inline text)</li>
</ul>
<p><strong>License:</strong></p>
<ul>
<li>Code and scripts © Kara C. Hoover, licensed under the <a href="LICENSE">MIT License</a>.</li>
<li>Data, figures, and written content © Kara C. Hoover, licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a>.</li>
</ul>
<hr>
</section>
<section id="tools-technologies" class="level2">
<h2 class="anchored" data-anchor-id="tools-technologies">Tools &amp; Technologies</h2>
<p><strong>Languages:</strong> None (no analysis script)</p>
<p><strong>Tools:</strong> AWS Bedrock | Amazon Nova Lite | Claude 4.5 Opus</p>
<p><strong>Packages:</strong> None</p>
<hr>
</section>
<section id="expertise" class="level2">
<h2 class="anchored" data-anchor-id="expertise">Expertise</h2>
<p><strong>Domain Expertise:</strong> prompt engineering | few-shot learning | LLM parameter optimization | biometric sensor validation | AWS Bedrock | structured output design | cost-performance trade-off analysis</p>
<p><strong>Transferable Expertise:</strong> This project demonstrates the ability to systematically evaluate and configure LLM behavior for constrained classification tasks – identifying which prompt design choices and parameter settings govern reliability, and how to match configuration to operational audience. The tiered parameter strategy (one template, multiple configurations) is applicable to any enterprise setting where AI outputs must serve different stakeholders with different reliability and interpretability requirements.</p>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>